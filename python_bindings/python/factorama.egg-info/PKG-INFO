Metadata-Version: 2.1
Name: factorama
Version: 1.0.0
Summary: Python bindings for the Factorama factor graph optimization library
Home-page: https://github.com/your-repo/factorama
Author: Factorama Contributors
Author-email: 
License: UNKNOWN
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Python: >=3.6
Description-Content-Type: text/markdown
Provides-Extra: stubs
Provides-Extra: test

# Factorama Python Bindings

Python bindings for the Factorama C++ factor graph optimization library.

## Installation

### Dependencies

First, install the required dependencies:

```bash
pip install pybind11 numpy pytest
sudo apt-get install python3-dev  # Linux
# or
brew install python  # macOS
```

### Building with CMake

From the project root directory:

```bash
mkdir build && cd build
cmake -DBUILD_PYTHON_BINDINGS=ON ..
make
```

This will build the `_factorama` extension module in the build directory.

### Installing the Python Package

After building with CMake, you can install the Python package:

```bash
cd python_bindings
pip install -e .
```

## Usage

### Basic Example

```python
import numpy as np
import factorama

# Create a factor graph
graph = factorama.FactorGraph()

# Create a robot pose variable
initial_pose = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])  # [tx, ty, tz, rx, ry, rz]
robot_pose = factorama.PoseVariable(1, initial_pose)
graph.add_variable(robot_pose)

# Create a landmark variable
landmark_pos = np.array([10.0, 0.0, 0.0])
landmark = factorama.LandmarkVariable(2, landmark_pos)
graph.add_variable(landmark)

# Add a prior factor
prior_mean = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
prior_information = np.eye(6) * 10.0
prior = factorama.GenericPriorFactor(3, robot_pose, prior_mean, prior_information)
graph.add_factor(prior)

# Finalize graph structure
graph.finalize_structure()

# Create and setup optimizer
optimizer = factorama.SparseOptimizer()
settings = factorama.OptimizerSettings()
settings.verbose = True
optimizer.setup(graph, settings)

# Optimize
optimizer.optimize()

print(f"Optimized pose: {robot_pose.value()}")
```

## Testing

Run the Python tests:

```bash
cd python_bindings
pytest test/
```

## Examples

See the `examples/` directory for more comprehensive usage examples:

- `simple_localization.py` - Basic robot localization using bearing observations

## API Reference

### Core Classes

- `FactorGraph` - Main container for variables and factors
- `SparseOptimizer` - Sparse optimization engine with Gauss-Newton and Levenberg-Marquardt methods

### Variables

- `PoseVariable` - SE(3) pose variables for robots/cameras
- `LandmarkVariable` - 3D landmark/point variables  
- `GenericVariable` - Arbitrary-dimension variables

### Factors

- `BearingObservationFactor` - Camera/robot bearing observations to landmarks
- `GenericPriorFactor` - Prior information on variables

### Enums

- `VariableType` - Variable type enumeration
- `FactorType` - Factor type enumeration  
- `OptimizerMethod` - Optimization method (GaussNewton, LevenbergMarquardt)

## Advanced Usage

The bindings expose most of the Factorama C++ API, including:

- Sparse Jacobian computation
- Residual vector access
- Variable cloning for numerical derivatives
- Detailed factor testing and debugging

Refer to the C++ documentation and header files for complete API details.

